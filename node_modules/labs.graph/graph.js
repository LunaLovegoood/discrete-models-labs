const TYPES = Object.freeze({
    WEIGHT_MATRIX: 'WeightMatrix',
    EDGE_LIST: 'EdgeList'
});

const ANY_GRAPH = Symbol('Any');

const createGraph = (type, vertices, edges) => ({ type, vertices, edges });

const createUndirectedEdge = (() => {
    class UndirectedEdge {
        constructor(first, second, weight) {
            this.first = first;
            this.second = second;
            this.weight = weight;
        }

        get vertices() {
            return [this.first, this.second];
        }

        has(vertex) {
            return this.first === vertex || this.second === vertex;
        }

        other(vertex) {
            if (vertex === this.first) {
                return this.second;
            }
            else if (vertex === this.second) {
                return this.first;
            }
        }

        connects(from, to) {
            return (this.first === from || this.second === from) &&
                (this.first === to || this.second === to);
        }
    }

    return (first, second, weight = 1) => new UndirectedEdge(first, second, weight);
})();

const defineGraphFunction = impl => {
    const graphFunction = (graph, ...args) => {
        if (!Reflect.has(impl, graph.type) && !Reflect.has(impl, ANY_GRAPH)) {
            throw new Error(
                `Missing implementation for graph type "${graph.type.description}".`
            );
        }
        const implFn = !Reflect.has(impl, graph.type)
            ? impl[ANY_GRAPH]
            : impl[graph.type];
        return implFn(graph, ...args)
    };
    graphFunction.impl = impl;
    return graphFunction;
};

const print = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices, edges: weightMatrix }) => {
        const alignment = 3;
        console.log(`  ${vertices.map(vertex => vertex.padStart(alignment)).join('  ')}`);
        weightMatrix.forEach((row, i) => {
            console.log(`${vertices[i]} ${
                row.map(weight => String(weight).padStart(alignment)).join('  ')
            }`);
        });
    },
    [TYPES.EDGE_LIST]: ({ vertices, edges: edgeList }, showWeight = true) => {
        console.log(`Vertices: ${vertices.join(', ')}`);
        edgeList.forEach(edge => {
            console.log(`${edge.first} -> ${edge.second}${
                showWeight ? ` (${edge.weight})` : ''}`);
        });
    }
});

const insert = defineGraphFunction({
    [TYPES.EDGE_LIST]: ({ edges: edgeList }, edge) => {
        edgeList.push(edge);
    }
});

const getEdges = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices, edges: weightMatrix }) => {
        const edges = [];
        weightMatrix.forEach((row, i) => {
            const first = vertices[i];
            row.forEach((weight, j) => {
                if (weight === 0) {
                    return;
                }
                const second = vertices[j];
                edges.push(createUndirectedEdge(first, second, weight));
            });
        });
        return edges;
    },
    [TYPES.EDGE_LIST]: ({ edges: edgeList }) => edgeList.slice()
});

const getVertices = defineGraphFunction({
    [ANY_GRAPH]: ({ vertices}) => vertices.slice()
});

const getAdjacentEdges = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices, edges: weightMatrix }, targetVertex) => {
        const vertexIndex = vertices.indexOf(targetVertex);
        return weightMatrix[vertexIndex]
            .map((weight, j) => {
                if (weight === 0) {
                    return null;
                }
                return createUndirectedEdge(targetVertex, vertices[j], weight);
            })
            .filter(edge => edge !== null);
    },
    [TYPES.EDGE_LIST]: ({ edges }, targetVertex) => {
        return edges.filter(edge => edge.has(targetVertex) &&
            edge.connects(targetVertex, edge.other(targetVertex)));
    }
});

module.exports = {
    TYPES,
    defineGraphFunction,
    create: createGraph,
    createUndirectedEdge,
    insert,
    getEdges,
    getVertices,
    getAdjacentEdges,
    print
};
