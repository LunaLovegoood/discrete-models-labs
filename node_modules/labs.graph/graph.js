const TYPES = {
    WEIGHT_MATRIX: Symbol('WeightMatrix'),
    EDGE_LIST: Symbol('EdgeList')
};

const createGraph = (type, data) => ({ type, data });

const createEdge = (from, to, weight = 1) => ({ from, to, weight });

const defineGraphFunction = impl => {
    const graphFunction = (graph, ...args) => {
        if (!Reflect.has(impl, graph.type)) {
            throw new Error(
                `Missing implementation for graph type "${graph.type.description}".`
            );
        }
        return impl[graph.type](graph.data, ...args)
    };
    graphFunction.impl = impl;
    return graphFunction;
};

const print = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices, weightMatrix }) => {
        const alignment = 3;
        console.log(`  ${vertices.map(vertex => vertex.padStart(alignment)).join('  ')}`);
        weightMatrix.forEach((row, i) => {
            console.log(`${vertices[i]} ${
                row.map(weight => String(weight).padStart(alignment)).join('  ')
            }`);
        });
    },
    [TYPES.EDGE_LIST]: (edgeList, showWeight = true) => {
        edgeList.forEach(edge => {
            console.log(`${edge.from} -> ${edge.to}${
                showWeight ? ` (${edge.weight})` : ''}`);
        });
    }
});

const insert = defineGraphFunction({
    [TYPES.EDGE_LIST]: (edgeList, edge) => {
        edgeList.push(edge);
    }
});

const getEdges = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices, weightMatrix }) => {
        const edges = [];
        weightMatrix.forEach((row, i) => {
            const from = vertices[i];
            row.forEach((weight, j) => {
                if (weight === 0) {
                    return;
                }
                const to = vertices[j];
                edges.push(createEdge(from, to, weight));
            });
        });
        return edges;
    },
    [TYPES.EDGE_LIST]: edgeList => edgeList.slice()
});

const getVertices = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices}) => vertices.slice(),
    [TYPES.EDGE_LIST]: edges => edges.reduce((acc, { from, to }) => {
        if (!acc.includes(from)) {
            acc.push(from);
        }
        if (!acc.includes(to)) {
            acc.push(to);
        }
        return acc;
    }, [])
});

const getAdjacentEdges = defineGraphFunction({
    [TYPES.WEIGHT_MATRIX]: ({ vertices, weightMatrix }, targetVertex) => {
        const vertexIndex = vertices.indexOf(targetVertex);
        return weightMatrix[vertexIndex]
            .map((weight, j) => {
                if (weight === 0) {
                    return null;
                }
                return createEdge(targetVertex, vertices[j], weight);
            })
            .filter(edge => edge !== null);
    }
});

module.exports = {
    TYPES,
    defineGraphFunction,
    create: createGraph,
    createEdge,
    insert,
    getEdges,
    getVertices,
    getAdjacentEdges,
    print
};
